### 综述

本问题可谓包罗万象。若按照学科门类分类，本问题大致涵盖了：理学、工学、教育学、艺术学、法学 的内容。

所以先划分一下陈述的范围：

结合我面试的目标——前端岗，以及我的专业，我在此就着重说一说工学->信息与通信工程->通信工程专业->微机原理和计算机网络的内容。额外还会说一点操作系统与浏览器的互动过程，以及浏览器内部的业务流程。

还要声明：

+ 由于本问题没有实例化，所以我只会说一些一般性的内容。

+ 由于很多不同功能的业务流程相互间串行、并行、循环、跳转，所以我计划按功能分类，由小到大叙述。所谓小，指的就是他们在整个宏观的业务流程内，会被不断反复的执行。所以我在此把重复的过程抽离出来，只说一遍。

+ 我不仅仅只说业务流程，还会附带解释一些相关的知识点。

### 微机原理

在任意的一个端到端的通信链路上，无论是你的PC，还是路由、亦或是DNS服务器、代理服务器、源服务器等等。。。这些设备，他们都是计算机。那么凡是计算机，业务的执行方式分为两种：轮询和中断，而中断占绝大部分。

#### 中断

当键盘上的一个键被按下，或者是网卡接收到了一串比特流，等等。。。。这个时候，你的CPU就会收到一个中断。那么CPU就会先去查一查。这个中断他的级别是不是够高？如果够高了 ，那么CPU就会立刻保存当前正在执行的上下文。也就是把含有执行上下文的寄存器的内容压到指定的一系列内存单元。这些内存单元是一个事先指定的栈。同时，CPU还会保存当前这个栈的栈顶地址以及当前所执行到的那一条指令的地址，也就是返回地址。保存完现场之后，CPU就开始查表，看一看：这个中断所对应的中断服务程序在中断向量表出的哪一个位置？查到之后，Program counter就指向这个终断服务程序的地址，从而让cpu开始执行中断服务程序。此后，在逐行执行这个中断服务程序的过程中，也可能会遇到其他的外部中断，内部中断或者是软中断，那么CPU就会递归的执行这个中断。而这个过程，和咱们上面讲的那些内容是一样的。之后，当一个中断服务程序执行完毕，CPU就会读取上次保存好的返回地址并让Program Counter指向该地址，还会让保存好的执行上下文POP到相应的寄存器中，从而CPU继续执行原先任务。



### 计算机网络

#### 计算机网络服务流程概括

+ 以整个计算机网络视角看：一条端到端的网络链路上请求一个文档的业务流程：

  浏览器请求并获得服务器ip地址->建立TCP连接和SSL会话->浏览器发出get命令->服务器给出响应，浏览器取得文档->释放TCP连接

  > 服务器可能是你预想的那个目标服务器，也可能是代理服务器

  

根据OSI体系结构（7层）和TCP/IP体系结构（4层），咱们把计算机网络按功能分为五层：物理层、数据链路层、网络层，运输层和应用层。由于我要应聘的是前端岗，我就着重讲一讲，运输层和应用层里的业务流程：

#### 运输层

先来看运输层干了什么：它主要的包含TCP协议和SSL协议的业务流程。

##### 运输层概括

以运输层视角整体看，含有报文加密和报文鉴别的TCP通信过程。

  为了不失一般性，不区分谁是客户谁是服务方，直接假定A和B通信。A把要发送的报文进行报文摘要运算，然后在把报文摘要用自己的私钥进行所谓的解密运算，也就是签名。然后签名的报文摘要附着于加密的报文，之后通过应用层一系列包装，通过因特网发送给B。B接收之后，B对这个密文进行A的逆操作就得到了明文。

##### TCP

TCP协议作为一个面向字节流的、采用全双工连接的协议，其首部功能很繁杂。咱们先看TCP连接建立和释放的大致过程，而不讲报文段首部的各个状态位、标志位。

+ 先梗概三次握手建立TCP连接。首先，你的用户端发了一个请求，和服务端说我想建立连接。然后，处于监听状态的服务端就说好，我确认建立连接，那么用户端又说，我确认了你的确认，那咱们开始吧。至此，连接就建立了。

+ 再梗概四次握手释放TCP连接：你的用户端向服务端发了个请求说，我想断开连接了。这个时候，服务端先把剩余的那点数据以一条报文的形式给你发了，然后又给你发了条报文说好，现在我发完了。我确认断开连接。然后用户端又说好，我确认你的确认。服务端这个时候就直接断开了，而用户端等了一段时间，确认服务端收到第四次握手的报文，也断开了。那么，四次握手释放TCP连接的过程就结束了。

  其中，第二次握手可能被省略。



##### TLS

**握手阶段的详细过程**

**1.客户端发出请求（ClientHello）**

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。

在这一步，客户端主要向服务器提供以下信息。

> （1） 支持的协议版本，比如TLS 1.0版。
>
> （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
>
> （3） 支持的加密方法，比如RSA公钥加密。
>
> （4） 支持的压缩方法。

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。

对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个[Server Name Indication扩展](http://tools.ietf.org/html/rfc4366)，允许客户端向服务器提供它所请求的域名。

**2.服务器回应（SeverHello）**

服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

> （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
>
> （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
>
> （3） 确认使用的加密方法，比如RSA公钥加密。
>
> （4） 服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。

**3. 客户端回应**

客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

> （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
>
> （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
>
> （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

至于为什么一定要用三个随机数，来生成"会话密钥"，[dog250](http://blog.csdn.net/dog250/article/details/5717162)解释得很好：

> "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
>
> 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
>
> pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。

**4. 服务器的最后回应**

服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。

> （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
>
> （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。







#### 应用层

##### 应用层概括

(1) 建立连接——DNS域名解析->TCP三次握手->TLS握手
(2) 接收请求——从网络中读取一条HTTP 请求报文。
(3) 处理请求——对请求报文进行解释，并采取行动。
(4) 访问资源——访问报文中指定的资源。
(5) 构建响应——创建带有正确首部的HTTP 响应报文。
(6) 发送响应——将响应回送给客户端。
(7) 记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中。

其中含有DNS解析服务、代理服务器工作流程、HTTP协议的业务流程

##### DNS

+ 浏览器先在本机的hosts中查询IP地址，若没有，就向本地DNS服务器递归查询IP地址。这时，本地服务器先查询自己是否存有所求。若无将代劳用户，迭代查询IP地址：先向根域名服务器查询，根域名服务器要么返回可能含有此IP映射表的DNS服务器的地址，要么直接返回结果。如此迭代下去，直到本地DNS服务器查到目标IP或者确信找不到，再把结果返回给用户。

  在上述过程中，任意一个DNS服务器在确认自己的高速缓存没有所求时才会发出请求。并且，在获得查询失败之外的结果后会将其放到自己的高速缓存中。

##### HTTP

HTTP考虑的是如何格式化要传输的信息。HTTP是无状态的，不存在建立连接和释放连接的说法，它的业务流程其实就是TCP业务流程的再包装。

> 2014年年中，IETF更新了HTTP/1.1协议：将原来的HTTP/1.1协议（[RFC2616](https://tools.ietf.org/html/rfc2616)）拆开，分成了六个单独的协议。在这六个新的协议说明中，重点对之前语义模糊的部分进行了重新诠释。更新之后的协议变得更易懂、易读。
>
> 以下是新的六个协议：
>
> - RFC7230 - [HTTP/1.1: Message Syntax and Routing](http://tools.ietf.org/html/rfc7230) - low-level message parsing and connection management
> - RFC7231 - [HTTP/1.1: Semantics and Content](http://tools.ietf.org/html/rfc7231) - methods, status codes and headers
> - RFC7232 - [HTTP/1.1: Conditional Requests](http://tools.ietf.org/html/rfc7232) - e.g., If-Modified-Since
> - RFC7233 - [HTTP/1.1: Range Requests](http://tools.ietf.org/html/rfc7233) - getting partial content
> - RFC7234 - [HTTP/1.1: Caching](http://tools.ietf.org/html/rfc7234) - browser and intermediary caches
> - RFC7235 - [HTTP/1.1: Authentication](http://tools.ietf.org/html/rfc7235) - a framework for HTTP authentication
>
> HTTP2：（服务端无需配置，可由中间代理实现HTTP1.1->HTTP2
>
> 要使用HTTP2，客户端和服务端必须启用HTTPS（HTTP2的标准未强制，但它的谷歌实现强制了）
>
> + 分帧传输
> + 信道复用
> + 消息主动推送

+ 请求报文格式：

  + 起始行（俗称请求行，Request Line）：方法 路径 版本CRLF 。如：GET https://www.baidu.com HTTP/1.1 

  + 首部（俗称请求头，header）

  + 实体主体（俗称请求体）：通常不用

+ 响应报文格式
  + 起始行（俗称请求行，Request Line）：版本 状态码 状态的文字描述 。如：HTTP/1.1 200 OK
  + 首部（俗称请求头，header）
  + 实体主体（俗称请求体）：与上一行内容由一个空行隔开

+ **重要的HTTP1.1报文首部及其重要指令：**

> 1、**注意：指令的语义虽然这么写，但它只是一个声明，只是为了告诉开发者该怎么实现，从而以约定好的形式将不同系统中的HTTP模块的功能统一起来，并不具备强制性。**
>
> 2、指令，也就是首部的值，用于**覆盖**任意系统中实现的HTTP模块的默认行为
>
> 3、实际书写中（由各种报文分析插件和开发者工具展示给你看，而不是让你码代码时写），若指令有参数，用等号分隔；一个首部若有多个指令，指令间用逗号分隔。
>
> 如：Cache-Control：private，max-age=0，no-cache
>
> 4、本节内容按HTTP的常见功能叙述了：缓存控制、缓存验证、长连接、数据协商、重定向
>
> 5、本节按照首部对报文的归属排版为：通用首部、请求首部、响应首部、实体首部、扩展首部

1. 通用首部：提供了客户端、服务端都可用的通用功能

   + 缓存控制

     1）**Cache-Control**：

   > ​	不管设不设置本首部都客观存在的默认行为：
   >
   > + HTTP1.1的连接均默认为持久连接（Connection：keep-alive）
   >
   > + 一条成功响应的http报文所在的网络传输路径上的任何缓存节点都倾向于缓存该报文，并在它新鲜时作为响应直接返回，或者在它过期后向源点服务器验证一下后作为响应返回。缓存节点包含：代理服务器、浏览器。缓存节点在以下表格中简称节点

   <Table>
         <caption style="height:60px;line-height:60px">在<strong >请求报文</strong>中,作为首部之一的Cache-Control所含的重要指令</caption>
         <colgroup>
             <col style="width:120px;"></col>
         	<col style="width:150px"></col>
     		<col style="width:120px"></col>
         </colgroup>
         <thead>
                 <tr>
                     <th>缓存控制功能的功能细分</th>
                     <th>指令</th>
                     <th>参数</th>
                     <th>含义</th>
                 </tr>
             </thead>
             <tbody> 
         		<tr >
                     <td rowspan="1"  >可缓存性</td>
                     <td>no-cache</td>
                     <td>无 OR 字段名</td>
                     <td>希望返回的结果不是缓存的报文</td>
                 </tr>     
                 <tr >
                     <td rowspan="1" >可存储性</td>
                     <td>no-store</td>
                     <td>无</td>
                     <td>禁止<sup>[1]</sup>任何缓存系统存储本报文</td>
                 </tr>
                  <tr >
                     <td rowspan="2">到期</td>
                     <td>max-age</td>
                     <td>必写。数值</td>
                     <td>设为N：如果缓存报文的年龄还没有到N秒就发给我。浏览器以及任何中间缓存均可将响应（如果是“public”响应）</td>
                 </tr>
                 <tr>
                     <td>max-stale</td>
                     <td>? 数值</td>
                     <td>设为N：缓存的报文即使过期了N秒我也照样收。</td>
                 </tr>
                 <tr>
                     <td rowspan="1" >缓存的可更改性</td>
                     <td>no-transform</td>
                     <td>无</td>
                    <td>不允许节点想当然地更改（例如压缩、编码）某些首部以及这些首部指向的实体主体<sup>[2]</sup>。</td>
                 </tr>
                  <tr >
                     <td rowspan="1">其他</td>
                     <td>min-fresh</td>
                     <td>必写。数值</td>
                     <td>设为N：如果缓存的报文再过N秒就过期，那你就别给我了</td>
                 </tr>
             </tbody>
     </Table>

   

   <Table>
         <caption style="height:60px;line-height:60px">在<strong >响应报文</strong>中,作为首部之一的Cache-Control所含有的重要指令</caption>
         <colgroup>
             <col style="width:120px;"></col>
         	<col style="width:150px"></col>
     		<col style="width:120px"></col>
         </colgroup>
         <thead>
                 <tr>
                     <th>缓存控制功能的功能细分</th>
                     <th>指令</th>
                     <th>参数</th>
                     <th>含义</th>
                 </tr>
             </thead>
             <tbody> 
         		<tr >
                     <td rowspan="3"  >可缓存性：什么样的报文拥有被缓存的资格</td>
                     <td>public</td>
                     <td>无</td>
                     <td>任意的响应报文都可被缓存到任意的节点中</td>
                 </tr>         
                 <tr>
                     <td>private</td>
                     <td>可省略</td>
                     <td>1、本报文专属某一个用户，禁止shared cache类型的缓存系统缓存本报文。</br>2、若本报文是一个缓存，那么只有响应给那个特定用户时本报文才有效</td>
                 </tr>
                  <tr>
                     <td>no-cache</td>
                     <td>无 OR 字段名</td>
                      <td>本报文可以作为缓存的内容，但：</br>每次使用前都要向服务器验证，验成功了才能使用。</br><strong>注意：本指令的含义与其字面意义不同。</strong></td>
                 </tr>
      			<tr >
                     <td rowspan="1" >可存储性：即使有资格成为缓存，但也不一定就能被存储</td>
                     <td>no-store</td>
                     <td>无</td>
                     <td>禁止<sup>[1]</sup>任何缓存系统存储本报文</td>
                 </tr>
   			 <tr>
                     <td rowspan="1" >缓存的可更改性</td>
                     <td>no-transform</td>
                     <td>无</td>
                    <td>不允许节点想当然地更改（例如压缩、编码）某些首部以及这些首部指向的实体主体<sup>[2]</sup>。</td>
                 </tr>
                  <tr >
                     <td rowspan="2">到期</td>
                     <td>max-age</td>
                     <td>必写。数值</td>
                     <td>设为N：如果所缓存的报文的年龄还没有到N秒就认为它还新鲜，可直接发出而不需要向服务器确认。</td>
                 </tr>
                 <tr>
                     <td>s-maxage</td>
                     <td>必写。数值</td>
                     <td>当该报文作为共享缓存时才生效（也就是存于代理服务器中时），用于覆盖max-age的功能。</td>
                 </tr>
                  <tr >
                     <td rowspan="2">重新验证</td>
                     <td>must-revalidate</td>
                     <td>无</td>
                     <td>即使过期了，但只要你和服务器确认了我也照样收。</td>
                 </tr>
                 <tr>
                     <td>proxy-revalidate</td>
                     <td>必写。数值</td>
                     <td>当该报文作为共享缓存时才生效（也就是存于代理服务器中时），用于覆盖max-age的功能。</td>
                 </tr>
             </tbody>
     </Table>

     > [1] 所谓禁止存储，指的是：不能故意将信息存储于非易失性存储器中、在转发信息之后，尽最大努力尽快从易失性存储中删除信息 
     >
     > [2] 具体见 https://www.ietf.org/rfc/rfc2616.txt 13.5.2节

   

   + 长连接

     1）**Connection**

     ​	设定了客户端/服务器的连接方式。取值为：

     + keep-alive：允许本报文传输路径所在的TCP连接的复用。其实也就是实现了所谓的HTTP长连接
     + close：本报文传输后关闭这条TCP连接

   

2. 请求首部：在请求报文中才有意义的首部

   + 缓存验证

     1）**If-Match**

     + 告知服务器：如果实体标记（If-Match）与文档当前的实体标记（即服务端文档的Etag）**强匹配**，就响应我的请求，否则返回412 Precondition Failed。其中，是不是强匹配，得由**服务端业务代码自己实现**，由它说了算（一般采用==判断，同时考虑通配符`*`的情形）。

     + 参数必写，取值范围与Etag取值范围一致。可使用通配符`*`

     2）**If-Non-Match**

     ​	与If-Match意义相反：如果提供的实体标记与当前文档的实体标记**不**匹配，就获取文档，否则得到412 Precondition Failed。

     3）**If-Modified-Since**

     + 指定了一个日期，告知服务器：如果在该日期之后资源被修改过，就返回此资源，否则返回304 Not Modified

     + 取值是形如`Sat, 29 Oct 1994 19:43:31 GMT`的时间戳。

     4）**If-Unmodified-Since**：与If-Modified-Since意义相反。

   + 数据协商

     > 对于Accept系列的首部，可设定其指令的权重来表示偏好程度：在指令后紧跟`;q=num`。floatNum是一个介于[0,1]的小数

     1）**Accept**
     
   + 请求方偏好的MIME类型
     + 常用的MIME类型
     + x-www-form-urlencoded：将字符串编码并传输
       + multipart/form-data：一个请求被划分为多个部分，而本报文是其中一部分。常用文件上传，因为文件需要分割、且作为二进制形态的数据（意味着不能向字符串那样编码）传输。

     2）**Accept-Encoding**

     + 请求方偏好的编码方式

     3）**Accept-Charset** 

     + 请求方偏好的字符集

     4）**Accept-Language** 

     + 请求方偏好的语言
     
     5）**User-Agent**
     
     + 发起请求的应用程序名称

3. 响应首部：响应报文特有的首部

   1）**Location**

   + 指出一个URL。通常于服务端的业务代码中配合3xx，将请求方引导到指定的URL上。（ 浏览器在接收到重定向响应的时候，会采用该响应提供的新的 URL ，并立即进行加载；大多数情况下，除了会有一小部分性能损失之外，重定向操作对于用户来说是不可见的。 ）

   + 301与302状态码：
     + 301永久跳转，直接请求跳转的那个网址，且浏览器会尽可能长时间地缓存并使用这个报文，从而超出服务端的控制（服务端更新了响应报文也没用，除非客户自己清除了缓存），故使用301要慎重。
     + 302暂时跳转，先请求原网址，再请求跳转网址

   2）**Vary**

   ​	给出一个首部列表（以空格分隔各个首部），**告知代理**：当**请求报文**含有这些首部时，代理应把该请求所对应的响应报文（也就是本报文）缓存为一份独立的版本，除非相同版本的响应报文已被缓存。下一次的请求报文若仍然具有相同的首部及其指令，那么认为请求的响应报文版本与缓存的一致，可将该缓存作为响应发送给请求方。

   > 这涉及到前后端的协作：前端发需要的报文首部（例如User-Agent、Cookie和任意的自定义的首部），后端需设定Vary予以配合，从而利用中间代理的缓存提升用户体验。

   

4. 实体首部：专门用于描述主体实体的首部，他们均由源服务器赋值，意为源服务器告诉客户端的信息

   + 缓存验证（响应报文）（若客户端禁用缓存，则请求报文中将不会有缓存验证相关的首部

     1）**Last-Modified**

     ​	语义上指的是由源服务器认定的该报文的上次修改日期，实际上可设为任意值。常配合**请求**首部：If-Modified-Since、If-Unmodified-Since来进行报文新鲜程度的检测

     2）**Etag**

     ​	Entity Tags，语义上指实体主体的标记，可认为是特定资源的**版本标识符**，当资源改动后此资源的Etag会被更新。可为任意值，一般设置为数字签名——最常见的就是用哈希算法计算文件内容后所得到的值。常常配合这些**请求**报文的首部一起使用：If-Match、If-Non-Match

   + 数据协商

     1）**Content-Type** 
     
     ​	这个主体的对象类型
     
     2）**Content-Encoding** 
     
     ​	对主体执行的任意编码方式
     
     3）**Content-Language** 
     
     ​	理解主体时最适宜使用的自然语言
     
     
     

5. 扩展首部：非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP 规范中去。即使不知这些扩展首部的含义，HTTP 程序也要接受它们并对其进行转发。

   + 在请求报文中：

     1）**Cookie**

     ​	客户端维护的cookie。如果收到了一个带有Set-Cookie的报文，浏览器就会存储这个cookie，并在下次请求时自动带上由Cookie首部描述的键值对形式的cookie值。如：Cookie：user=HuaiNian,uid=1

   + 在响应报文中：

     1）**Set-Cookie**

     <Table>
           <caption style="height:60px;line-height:60px">　版本0（网景）Set-Cookie的指令及其后续非标准扩展</caption>
           <colgroup>
             <col style="width:120px;"></col>
           	<col style="width:120px"></col>
     		<col style="width:75px"></col>
           </colgroup>
           <thead>
                   <tr>
                       <th>指令</th>
                       <th>参数值</th>
                       <th>强制性</th>
                       <th>含义</th>
                   </tr>
               </thead>
               <tbody> 
           		<tr >
                       <td>NAME</td>
                       <td>VALUE</td>
                       <td>强制</td>
                       <td>NAME 和VALUE 都是任意的字符序列，除非包含在双引号内，否则不包括分号、逗号、等号和空格。客户端会在后继对站点的访问中将其送回给Web 服务器</td>
                  </tr>
                  <tr >
                     <td>expires</td>
                  	<td>日期字符串</td>
                     <td>可选</td>
                      <td>定义了cookie 的实际生存期。一旦到了过期日期，就不再存储或发布这个cookie 了。日期的格式为：<center>Weekday, DD-Mon-YY HH:MM:SS GMT</center>唯一合法的时区为GMT,各日期元素之间的分隔符一定要是长划线。如果没有指定Expires， cookie 就会在用户会话结束时过期。<strong> 如果已经定义了max-age 或者 s-maxage 那么expires将被忽略</strong></td>
                  </tr>
                  <tr >
                     <td>domain</td>
                  	<td>域名字符串</td>
                     <td>可选</td>
                      <td>指定了一个域名。告诉浏览器以后只向匹配了该域名的服务器发送cookie。</br>如：在URL为test.com的页面中设置<code>Set-Cookie：domian=test.com</code>后，页面a.test.com和b.test.com都可访问该cookie。</br><strong>注意：不要跨域设置cookie。</strong></br>如：在URL为a.test.com的页面中设置的<code>Set-Cookie：domian=test.com</code>无效！！因为前者是二级域名，后者是一级域名</td>
                  </tr>
                  <tr >
                     <td>path</td>
                  	<td>路径字符串</td>
                     <td>可选</td>
                     <td>为特定的URL分配cookie。如果Path 属性
                         是一个请求的URL 路径前缀，就为该请求的响应报文分配一个cookie。</br>如：路径/foo 与 /foobar 和 /foo/
     bar.html 相匹配。路径“/”与域名中所有内容都匹配。</td>
                  </tr>
                  <tr >
                     <td>secure</td>
                  	<td>-</td>
                     <td>可选</td>
                     <td>如果包含了这一属性，就只有在HTTP使用SSL安全连接时才会发送cookie</td>
                  </tr>
     			<tr >
                     <td>HttpOnly</td>
                  	<td>-</td>
                     <td>可选</td>
                     <td>禁止以JavaScript手段获取cookie（document.cookie），从而防止跨站脚本攻击</td>
                  </tr>
     			<tr >
                     <td>max-age</td>
                  	<td>整数</td>
                     <td>可选</td>
                     <td>设置了以秒为单位的cookie 生存期。cookie
     的年龄比max-age 大时，客户端就将这个cookie 丢弃。值为零说明
     应该立即将那个cookie 丢弃（所谓丢弃，指的是在返回报文中不会使用首部Cookie携带该cookie的信息）</td>
                  </tr>
               </tbody>
       </Table>
     
     > + cookie 是由服务器贴到客户端上，由客户端维护的状态片段。
     > + document.cookie就是一个对象，包含了当初Set-Cookie所设置的一系列键值对
     > + 在NodeJS中，Set-Cookie的值是一个数组
     >+ 当前广泛使用的cookie不严格遵从于任何一个标准
     
     2）**Content-Security-Policy**
     
     + 缩写CSP，限制客户端的资源获取（直接不向那个资源发送请求）、向服务端报告客户端资源获取越权。这个扩展首部由W3C定义：https://w3c.github.io/webappsec-csp/
     
     + 利用meta标签实现页面形式的CSP
     
       ~~~html
       <meta http-equiv="相关的首部" content="指令">
       ~~~
     
       但是，有些首部及其指令是不可用的。
     
     + 指令
     
       + default-src
     
         限制任何资源的加载请求：浏览器只能请求本指令指出的资源。本指令与参数用**空格分隔**。常见参数有：
     
         + 以域名或者 IP 地址表示的主机名，外加可选的 URL 协议名。例如：
           + `http://*.example.com:` 匹配从使用 http: 的 example.com 的任意子域的资源加载。
           + `mail.example.com:443:`匹配对 mail.example.com 上的 443 端口号的访问。
           + `https://store.example.com`: 匹配对使用了 https: 的 store.example.com 的访问。
     
         + 带有冒号的协议名
         
           + `http:`   以及   `https:` 
           + `data:` 允许 [`data:` URIs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) 作为内容的源*。这是不安全的。攻击者可以注入任意 data: URI 。不要轻易使用这种形式的源，尤其是脚本，绝对不要使用。*
      + `mediastream:` 允许 [`mediastream:` URIs](https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_API) 作为内容的源*。*
         + `blob:` 允许 [`blob:` URIs](https://developer.mozilla.org/en-US/docs/Web/API/Blob) 作为内容的源*。*
           
         + `filesystem:` 允许 [`filesystem:` URIs](https://developer.mozilla.org/en-US/docs/Web/API/FileSystem) 作为内容的源*。*
           
         + `'self'`
         
           只允许页面加载当前URL指向的主机的资源，包括相同的 URL scheme 与端口号。`'self'`必须有单引号。一些浏览器会特意排除 blob 与 filesystem 。需要设定这两种内容类型的站点可以在 Data 属性中进行设定。
     
       + `'unsafe-inline'`
         	允许使用任何内联资源（**CSP默认禁用任何内联元素**）。内联元素有：内联script元素、javascript: URL、内联事件处理器以及内联style元素。必须有单引号。
       
       + script-src
         与default-src类似，只不过限制的只有对JavaScript文档的请求。
     
       + connect-src
     
         与default-src类似，只不过限制的只有JavaScript对URL资源的请求。常用于限制Ajax操作的URL
     
       + form-action
     
         给出一个地址，当前页面的 form 只能提交到这个地址。
     
       + report-uri
     
         给出一个URI，支持相对路径。  当出现可能违反CSP的操作时，让客户端报告给服务器。这些违规报告会以JSON文件的格式通过POST请求发送到这个指定的URI 。每一项违反操作都会生一份独立的报告。不支持在HTML`<meta>`元素中的使用。
     
     3）**Content-Security-Policy-Report-Only**
     
     ​	用于监视并打小报告，必须设置report-uri指令（不然还有何意义？！）。其指令与Content-Security-Policy一致，只不过在Content-Security-Policy中用于限制，而在本首部中用于监视。不支持在HTML`<meta>`元素中的使用

##### 代理服务器

为了减少专线链路上的通信量，提高服务质量，运营商常常会部署代理服务器。它有时候作为服务器代替源点服务器返回消息，有时候作为客户端来代表用户向外界请求消息。

+ 当浏览器向因特网的服务器发送请求时，就先和区域网中的代理服务器建立TCP连接，并向代理服务器发送HTTP请求报文。

+ 若代理服务器已经存放了所请求的对象，代理服务器就把这些对象放入HTTP响应的报文中返回给你的浏览器，否则，代理服务器就代表发出请求的用户浏览器与因特网上的源点服务器建立TCP连接并发送HTTP请求报文。

+ 源点服务器把所请求对象放在HTTP响应报文中返回给代理服务器。代理服务器收到这个对象后，先将其复制一份放在自己的存储器中，然后再把这个对象放在HTTP响应报文中通过已建立的TCP连接返回给请求该对象的浏览器。

  





### 浏览器内部工作流程

浏览器的主要结构：js引擎、渲染引擎、用户界面、网络模块、数据库 整体概括:识别输入->发出请求->读取响应->渲染

#### 异步的网络业务流程(HTTPS)

> 原文见：https://developer.chrome.com/docs/devtools/network/reference/#timing-explanation

+ 资源调度

  - 排队

    - 当有更高优先级的时候
	  - 当有6个TCP连接的时候
    - 浏览器正在简要地分配磁盘缓存中的空间 

+ 建立连接

  - 暂停：当浏览器遇到以上排队的原因时会暂停建立连接。
  - DNS解析
  - 与代理服务器协商请求

+ 发送请求

  - 启动ServiceWorker
  - 请求ServiceWorker
  
  > Service Worker 是浏览器在后台独立于网页运行的脚本
  >
  > - 它是一种 [JavaScript Worker](https://www.html5rocks.com/en/tutorials/workers/basics/)，无法直接访问 DOM。 Service Worker 通过响应 [postMessage](https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage) 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。
  > - Service Worker 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。
  > - Service Worker 在不用时会被中止，并在下次有需要时重启，因此，您不能依赖 Service Worker `onfetch` 和 `onmessage` 处理程序中的全局状态。 如果存在您需要持续保存并在重启后加以重用的信息，Service Worker 可以访问 [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)。
  > - Service Worker 广泛地利用了 promise，因此如果您不熟悉 promise，则应停下阅读此内容，看一看 [Promise 简介](https://developers.google.cn/web/fundamentals/getting-started/primers/promises)。
  
  - 等待首次响应(TTFB)：这段时间包含了由请求到响应的全程网络延迟和服务端处理该响应所消耗的时间。（TTFB 意为 for Time To First Byte）
  - 下载内容： 接收响应报文



#### 渲染引擎的工作流程

Renderer Process负责渲染。

![img](images/webkitflow.png)

绘制一个页面需要哪些东西？

先搞清楚**我们需要考虑的业务流程的终点**：GPU面向的业务很单一：把收到的帧展示出来。即需要页面的**帧**。

而GPU的控制单元很简单，处理不了复杂的业务流程，那么CPU需要把上述内容交给它，而怎么交给他就是我们要考虑的业务流程。此处使用逻辑倒推的方式说明：

需要页面的帧——>

要先明确帧的组成：记录有自己坐标、色彩信息、内存地址的一系列像素块，他们被compositor合并为帧——>

要先将图像栅格化（Rasterizing）——>

raster thread 负责栅格化，但只能处理小图——>

compositor thread要先将图层切块（tile）——>

图层从哪来，怎么叠加的：创建每一个图层的信息（LayerTree）、绘制顺序（绘制记录）——>

要先知道：元素的几何形状和位置（LayoutTree）、元素的样式（Render Tree）——>

要先知道：文档结构、内容（DOM Tree）、StyleSheet 的内容(CSSOM Tree)



##### 画什么？

解：收集、计算出所需要的信息：

1. 预解析

   找出并加载需要通过网络加载的其他资源，确保外部资源（例如外部脚本、样式表和图片）的引用都下载了。

2. 解析

   词法分析->语法分析->构造树，得到文档的结构（DOM Tree）和每一个元素的样式（CSSOM Tree）

3. 构造RenderTree

   对于每一个CSSOM节点，以**从右向左**方式扫描选择器从而和DOM节点建立映射，根据映射关系合成一棵**RenderTree**

4. 构造LayoutTree

   从RenderTree根节点开始递归地调用子节点的 layout/reflow方法，构造**LayoutTree**，从而确定元素的几何形状和位置。

5. 创建PaintRecords

   根据**LayoutTree**给出一个合理的绘制顺序：**PaintRecords**

6. 构造LayerTree

   根据**LayoutTree**将页面划分为不同的图层（layer），从而构造**LayerTree**

   


##### 怎么画？

1. 图层切块（tile）

   每一个图层按指定的分辨率被 compositor thread 分成小块，并分别交给**很多的** raster thread 

2. 栅格化（Rasterizing） 

   raster thread将收到的小块栅格化并存储到GPU的内存中( 栅格化的小块称为**draw quad** ，一个draw quad记录了自己的屏幕坐标、色彩信息和内存地址）

   > 独立显卡有显存，而集成显卡没有显存，要从电脑内存中划分一块给它。

   

3. 合并（Compositing）：将这些draw quad合并为**帧**（具体讲，合并指的是将各个draw quad的内存地址排列组合到一起。帧就是那一秒页面整体的图像）



​	

#### JS引擎的工作流程（V8）

1. 解析

   解释器将完成以下操作：

   + 词法分析

     词法分析器（Lexer）将源代码转换成一系列的标记（Token），标记通常对应着关键字、变量名、运算符、数字、字符串、注释等

   + 语法分析

     语法分析器（Parser）将一系列的标记转换成抽象语法树（Abstract Syntax Tree，AST）。AST 是一种树形结构，它的每个节点表示程序的一个语法结构，比如语句、表达式、函数等。

2. 编译

3. 执行

> 执行上下文对象在函数调用时创建，用于追踪代码的执行情况，包括以下几个方面：
>
> 1. 变量对象（Variable Object）：变量对象是一个键值对，包含了当前上下文中定义的所有变量和函数声明。在函数执行之前，JavaScript 引擎会将当前上下文的变量对象初始化，包括函数的参数、内部变量和函数声明等。在函数执行过程中，变量对象可以被用来查询、设置和删除变量和函数。
> 2. 作用域链（Scope Chain）：作用域链是一个由变量对象组成的链表，用于保证变量访问的正确性。作用域链的第一个对象是当前上下文的变量对象，每个链表节点都引用了一个外部上下文的变量对象。JavaScript 引擎在访问变量时会沿着作用域链向上查找，直到找到第一个匹配的变量为止。如果在整个作用域链中都找不到对应的变量，则会抛出 ReferenceError 异常。
> 3. this 值（This Binding）：this 值用于引用当前函数执行的上下文对象，它的值在函数执行时被确定。如果函数是作为对象的方法被调用的，则 this 指向该对象；如果函数是全局函数，则 this 指向全局对象（浏览器中的 window）；如果函数是通过 apply、call 或 bind 方法调用的，则 this 指向方法调用的第一个参数。
> 4. 闭包引用（Closure References）：当一个函数中定义了另一个函数时，内部函数可以访问外部函数的变量和参数，这种特性称为闭包。闭包中的内部函数会引用外部函数的变量对象，导致该变量对象在外部函数执行完毕后仍然存在于内存中，从而形成了闭包。闭包可以用于实现私有变量、模块化等功能。
> 5. 可执行代码（Executable Code）：可执行代码是一个存储了 JavaScript 代码的抽象对象，它包括了函数体中的语句和表达式。在函数被调用时，JavaScript 引擎会根据可执行代码来执行函数体中的语句和表达式。

##### 全局代码

+ 创建一个执行栈
+ 创建一个全局执行上下文，为所有变量分配内存并赋初始值（undefined）
+ 全局执行上下文push到执行栈中
+ JS引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。

##### 函数代码

如果代码中存在function的声明和调用

+ 创建一个函数执行上下文，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。
+ 当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。

> 很简单但很重要的概念——栈的性质：**围出一片区域**
>
> 将执行上下文push到栈意味着什么：意味着栈顶和栈底指针围出的那一片内存单元区域可以随时被访问。而随栈顶指针的下移，这些pop出的内容没有再被访问的机会，下一次栈顶指针指向它的时候就是他被覆盖的时候。所以我把执行栈的pop称为**垃圾回收**。

##### 闭包的处理

在子函数执行的过程中，父函数已经return了，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。

##### 异步代码的执行（事件循环）

异步代码放到任务队列由NativeCode代为执行，而同步代码放入主线程的执行栈执行，以轮询的方式在主线程和任务队列间切换。

一轮事件循环的过程为：

- 主线程执行执行栈（call stack）中的任务直至清空
- 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue
-  取出macrotask queue中位于队首的**一个**任务结果，放入执行栈中执行

> (macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)
>
> microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)

#### 浏览器工作流程中的重要概念

+ 语句解析

  + 词法分析，将语句分解为特定的标记构成的段落
  + 语法分析，逐个分析标记段落，构造解析树
  + 按照业务流程的要求，有序地遍历解析树，将语句解释为机器码

+ 文档流（NornalFlow）

   元素盒子从左到右，从上到下依次布局，文档中靠后的元素不会影响前面元素的几何特性 

+ 共享样式数据

  WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：

  1. 这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）
  2. **任何元素都没有 ID**
  3. 标记名称应匹配
  4. 类属性应匹配
  5. 映射属性的集合必须是完全相同的
  6. 链接状态必须匹配
  7. 焦点状态必须匹配
  8. **任何元素都不应受属性选择器的影响**，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配
  9. **元素中不能有任何 inline 样式属性**
  10. **不能使用任何同级选择器**。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。

+ CSSOM（呈现树） 树和 DOM 树
  
  CSSOM 树和 DOM 树的元素是相对应的，但并非一一对应。
  
+ 非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。
  
  + 有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。
  
+ 另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。
  

有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。

  

  ![img](images/image025.png)

  图：呈现树及其对应的 DOM 树 ([3.1](#3_1))。初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。

+ 样式表层叠顺序

  某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：

  1. 浏览器声明
  2. 用户普通声明
  3. 作者普通声明
  4. 作者重要声明
  5. 用户重要声明

  

  浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据[特异性](#Specificity)进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。

+ 特异性

  选择器的特异性由 [CSS2 规范](http://www.w3.org/TR/CSS2/cascade.html#specificity)定义如下：

  - 如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)
  - 记为选择器中 ID 属性的个数 (= b)
  - 记为选择器中其他属性和伪类的个数 (= c)
  - 记为选择器中元素名称和伪元素的个数 (= d)

  将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。

  

  您使用的进制取决于上述类别中的最高计数。
  例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p ...（在选择器中出现了 17 个标记，这样的可能性极低）。

  一些示例：

  ```
   *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
   li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
   li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
   ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
   ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
   h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
   ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
   li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
   #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
   style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
  
  ```

+ 一条TCP报文段的首部（20字节

  + 源端口和目的端口
  + 字节流中每一个字节的序号（建立连接时设置

    + 可定义长度为2<sup>32</sup>，即最多允许在网络上滞留4GB的数据
  + **文段号N（Seq）**：表明编号为N-1的字节流都收到了，期望发送N及N之后编号的数据
  + 首部长度
  + 紧急命令URG：意味着该报文段含有紧急数据，且该数据在数据段最前面
  + 紧急指针：当URG=1时有意义。指出了紧急数据的字节长度。
  + **确认ACK**：建立连接后，所有报文段的ACK必须为1，否则该报文段无效
  + 推送：接收方要求发送方不必等待缓存满（或达到MSS），而是立刻发送报文段
  + 复位RST：当为1时表明TCP连接出现严重差错，必须释放连接再重新建立连接
  + **同步SYN**：用且只于建立连接。当SYN=1且ACK=0时，表明这是第一次握手。当SYN=1,ACK=1时，表明这是第二次握手。
  + 终止FIN：释放连接
  + 窗口：值为[0,2<sup>16</sup>-1]的数，单位是字节。（即最大允许64KB），表明接收方允许发送方的发送量。这个值保持动态变化。紧急数据的发送不受窗口限制。
  + 检验和：
  + 选项
    + 该报文段中数据字段的最大长度MSS。（注意：首部+数据段=报文段
    + 窗口扩大选项：双方协商。移位值S，最大值14，即窗口最大可向左扩展为2<sup>16+14</sup>=2<sup>30</sup>（1GB
    + 时间戳
      + 报文段往返时间RTT
      + 处理高速网络中确认号超过2<sup>32</sup>的情况
    + 选择确认SACK

