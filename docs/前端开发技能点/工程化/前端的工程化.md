## 前端工程化水平的四个阶段

这不是开发流程，而是前端项目的工程化程度的四个分级

### 第一阶段：库/框架选型

### 第二阶段：**自动化**构建

+ 选型一种**自动化**构建工具，对代码进行校验、编译、精简、压缩，之后再以页面为单位进行简单的资源合并、测试。

  > 比如：构建工具可能有这样一个流程：
  >
  > + 校验（lint）：检测代码是否符合书写规范
  >
  > + 编译（或预处理）（parser）：将less、sass、es6、react等语言文件编译为标准的CSS、JS、HTML文件
  > + 精简：去除空白字符、去除无用的声明、去除可省略的符号、去除注释、缩短条件判断、缩短变量名等
  > + 压缩(compress)： 使用[packer](http://dean.edwards.name/packer/)的base64编码将原文压缩为带有字符表、解压器的压缩后原文。
  > + 合并：将该页面的图片合并为精灵图、将css文件合并为一个...
  > + 测试：测试代码行为是否与预期一致

  

+ 常见工具有：NPMScripts、Glup、Grunt、Rollup

### 第三阶段：JS/CSS模块化开发

所谓模块化开发也就是对各种开发语言**分而治之**的前提下，将一种开发语言的代码按照功能分出多个文件，一个文件拥有一种功能，称为一个模块，而各个功能模块相互依赖组成这种开发语言的代码的整体结构。

> 比如：JS代码不和CSS代码混合的前提下（js写在.js文件中，css写在.css文件中），对于JS语言，按照功能将js代码分别放在不同的js文件中，而这些js文件**按某种规则**相互依赖。其中的“某种规则”就是称为模块化方案。

+ JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等。JS的模块打包工具：  Browserify （CommonJS）、 RequireJS（AMD） 、 Webpack（都支持）  
+ CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。 

### 第四阶段：组件化开发与资源管理

 第四阶段前端开发最迫切需要做好的就是在基础架构中**贯彻增量原则**。 

+ 所谓组件化

  + 页面上的每个 **独立的** 可视/可交互区域视为一个组件；
  + **每个组件对应一个工程目录**，组件所需的各种资源都在这个目录下**就近维护**；
  + 由于组件具有独立性，因此组件与组件之间可以 **自由组合**；
  + 页面只不过是组件的容器，负责组合组件形成功能完整的界面；
  + 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。

  基于模块化和组件化的理念，前端开发的基本工程结构成了这个样子：

  | 示意图                                                       | 描述                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | [![img](images/constructor.png)](images/constructor.png)     | 整个Web应用由页面组成                                        |
  | [![img](images/modular_2.png)](images/modular_2.png)         | 页面由组件组成                                               |
  | [![img](images/modular-component.png)](images/modular-component.png) | 一个组件一个目录，资源就近维护                               |
  | [![img](images/modular_4.png)](images/modular_4.png)         | 组件可组合， 组件的JS可依赖其他JS模块， CSS可依赖其他CSS单元 |

  综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构：

  [![img](images/files-x.png)](images/files-x.png)

  如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护

+ 所谓的资源管理

  即构建“智能”的资源加载方案： **静态资源管理系统 = 资源表 + 资源加载框架** 

  +  资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容 

  + 资源加载框架提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。根据业务场景的不同，加载框架可以在浏览器中用JS实现，也可以是后端模板引擎中用服务端语言实现，甚至二者的组合，不一而足。